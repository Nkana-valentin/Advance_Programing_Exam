### Advance Programming  Exam report (C++) 

I have uploaded the forthcoming files:

1) "bst.hpp", containing the C++ implementation of a binary search tree;

2) "benchmark.cpp", containing a C++ implementation which is used to measure the performance of the find() method for the binary search tree (unbalanced and balanced ) and for the std::map;

3) "makefile", which is used to compile the files;

4) "mean_std.awk", an awk script which computes mean and standard deviation of data contained in a single column file;

5) "action.sh", and "actions_small.sh", bash scripts which run the benchmark for big and small tree/map and produces three data files (for unbalanced tree, balanced tree, std::map each) containing mean and standard deviation for measurements;

6) "plot.gnu", "plot_small.gnu" gnuplot scripts used to generate the plots.

7) "timing.png" and "timing_small.png" generated with the scripts.


### How to compile and run the benckmark

The compilation of the files is done by running the 'make' command; use the command 'make clean' to remove object files and executables.

The executable 'benchmark.x' requires an argument from command line representing the number of nodes in the tree and std::map : e.g we can run './benchmark.o 50' will run the tests for a tree and std::map with 50 nodes of (random int keys and int values). The corresponding output will be three sets of 11 time measurements for the find() method (for unbalanced tree, balanced tree, std::map each).

**Note**: The bash scripts can be used by running './actions.sh' or ./actions_small.sh'; the gnuplot scripts can be used by running "gnuplot plot.gnu" or 'gnuplot plot_small.gnu'.

**Note2**: To test the memory leak with valgrind can be done as follows:
'valgrind --leak-check=full --verbose --show-leak-kinds=all ./benchmark.o 50'

### BST implementation

The bst class was implemented on a new type (struct) Node, with containts:

1) a std::pair of templated (key, value) data;

2) two std::unique_ptr which can be used to point to a left/ right Node in a bst;

3)  a raw pointer which  can be used to a parent Node in a bst.

Additionnaly, the bst class itself contains instead:

1) a std::unique_ptr to the root Node (of templated key, value)

2) a templated comparaison functions (used to compare templated keys of the bst Nodes), which defaults as std::less.

All methods requested by exercise for the bst have been implemented

### Benchmark

The 'benchmark.x' executable runs a few tests to evaluate the time needed for the find() method to traverse a bst (balance/ unbalanced ) or a std::map. Ideally, the time needed should follow a log_2(N) behavior, with N the number of nodes in the tree/ std::map.

### The doc folder is generated by Doxygen view

In the first plot, generated by 'actions_small.sh' and 'plot_small.gnu', it is shown the obtained timings for small N, were the log_2(N) expected increasing behaviour should be lore visible:  ![ timing_small.png] (timing_small.png). The increasing looks indeed present, but  the fluctuations are too  big to compare it against  a log_2(N) behaviour.

In the second plot, generated by 'actions.sh' and 'plot.gnu', it is shown the obtained timings for large N, where log_2(N) expected behavior is constant: ![ timings.png] (timing.png)

From the plot instead we see a general increasing behaviour after a certain N, but actually the resulting plot varies a lot depending on the run. It is therefore quite hard to really establish the of the find() method; having more time. It might be possibe to study this problem further.


